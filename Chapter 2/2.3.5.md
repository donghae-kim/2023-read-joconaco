## 2.3.5 층이 너무 얇아질 때
코드를 별개의 계층으로 세분화하면 장점이 많지만 다음과 같은 추가 비용이 발생한다.

- 클래스 정의,의존성을 새 파일로 import 하기위해 반복된 코드가 발생한다.
- 로직의 이해에 많은 노력이 필요하다.
- 인터페이스의 추상화로 인해 로직을 이해하거나 디버깅하는것이 더 어려워진다.

코드의 다른 계층을 분할해서 얻는 장점보다 비용이 더 큰 시점이 올 수 있으므로 상식에 맞게 적용하는게 좋다.

### 예제 2.9

ParagraphFinder 클래스를 시작 오프셋 파인더, 종료 오프셋 파인더로 나눈다.

이 파인더들은 공통인터페이스 OffsetDetector를 implement한다.

이렇게 함으로써 좀 더 많은 계층을 갖는 코드가 보여진다.


> ParagraphFinder → \
OffsetDetector(Interface) → \
ParagraphStartOffsetDetector  || ParagraphEndOffsetDetector
>
ParagraphStartOffsetDetector  || ParagraphEndOffsetDetector 이 코드들은 다른곳에서 사용될 가능성이 없기에 코드의 계층이 너무 얇아졌다. **불필요하게 계층을 너무 잘게 쪼갰다.**


### 코드 계층 규모 결정

코드 계층 규모를 올바르게 결정하는 것은 중요하다.

계층이 너무 크면 쪼개져야 할 여러 추상화가 모듈화되지 않았고, 재사용 못하며, 가독성이 낮다.

계층이 너무 얇으면 불필요한 복잡성일 초래한다.

**일반적으로 너무 많은 일을 하는 계층은 너무 적은 일을 하는 계층보다 문제가 될 수 있다.**

계층이 너무 두꺼운지 판별할 기준은 없다.

자신이 만든 계층이 코드 가독성을 높이고, 재사용 가능하고, 일반화할수 있고, 모듈화되는지 스스로 판단하고 생각해보라.
