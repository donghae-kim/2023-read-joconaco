## 2.3.4 인터페이스

인터페이스란 **어떤 함수를 외부로 노출할 것인지 결정**하는 것이다. 이렇게 함으로써 계층 사이를 구분하고 **세부사항이 유출되지 않도록** 할 수 있다. 그 후 인터페이스에 정의된대로 클래스가 해당 계층에 대한 코드를 구현한다.

### 언제 사용하면 좋을까

하나의 추상화 계층에 대해 여러가지 방식으로 구현을 할 경우 인터페이스 사용하는 것이 좋다.

추상화 계층을 깔끔하게 구현하는 코드를 만들 때 좋다.

### 예시

텍스트 요약에 점수를 매기는데 여러가지 방법 중 어떤 방식을 채택해야할지 모르는 상황이다.

1. 단락의 중요도를 계산하기 위해 단어의 중요성을 고려하는 단순방법
2. 단락이 중요한지 결정하는 기계학습 모델을 사용하는 방법

이 두가지를 모두 구현해 놓고 고민하기 위해 `TextImportanceScorer` Interface를 만들고 구현체로 `WordBasedScorer`, `ModelBasedScorer`을 만든 모습이다.

![Untitled](https://user-images.githubusercontent.com/86547109/221367225-66c0d2bb-d624-4a3e-985b-95ec146608c4.png)

인터페이스를 정의함으로써 하위 문제를 해결하는 구현 클래스를 쉽게 교체할 수 있다.

`TextSummarizer` 함수가 `WordBasedScorer`와 `ModelBasedScorer`를 이제 그때그때 원할 때 사용할 수 있다.

### 항상 인터페이스를 쓰는 것이 좋은가?

위에서 처럼 2개 이상의 구현이 아닌 한가지 구현만 있고 추가할 계획조차 없어도 인터페이스를 쓰는게 좋을까 ? 에 대한 답은 팀by팀 이라고 할 수 있다. 하지만 몇몇 SW공학은 인터페이스를 사용할 것을 권고한다.

### 인터페이스 장점

- 퍼블릭 API를 매우 명확하게 보여준다.
    - 사용해야하는 기능과 사용하지 말아야하는 기능에 대해 혼동할 일이 없다.
    - 새롭게 퍼블릭 함수를 추가하더라도 상위계층에 노출이 되지 않는다.
- 한가지 구현만 필요하다고 잘못 추측한 것 일 수도 있다.
    - 추후에 2개 이상의 구현이 필요할 경우 유지보수 하기에 쉽다.
- 테스트를 쉽게 할 수 있다.
    - 테스트 중에 MOCK이나 페이크 객체로 대체하기 쉬워서 테스트가 쉽다.
- 같은 클래스로 두가지 하위 문제를 해결할 수 있다.
    - 한 클래스가 두개 이상의 서로 다른 추상화 계층에 구현을 제공할 수 있다.
    - EX) LinkedList → List 및 Queue 모두 구현

### 인터페이스 단점

- 더 많은 작업이 필요하다
    - 코드를 더 작성해야한다.
- 코드가 복잡해 질 수 있다.
    - 단순하게 코드를 찾아가는 것이 아닌 인터페이스로 이동하고 구현하는 클래스를 찾고 복잡해진다.

### 필자 정리

모든 클래스에 인터페이스를 붙이는것은 통제가 불가능하다. 그러므로 인터페이스의 장점을 극대화 시킬수 있는 상황에서는 사용하되 인터페이스만을 위한 인터페이스는 사용하짐라ㅏ.

그럼에도 깨끗하고 뚜렷한 추상화 계층을 만드는데 집중하고, 구현 세부사항이 유출되지 않도록 어떤 함수를 퍼블릭을  노출할지 신중하게 생각하라.

---

## 2.3.5 층이 너무 얇아질 때
코드를 별개의 계층으로 세분화하면 장점이 많지만 다음과 같은 추가 비용이 발생한다.

- 클래스 정의,의존성을 새 파일로 import 하기위해 반복된 코드가 발생한다.
- 로직의 이해에 많은 노력이 필요하다.
- 인터페이스의 추상화로 인해 로직을 이해하거나 디버깅하는것이 더 어려워진다.

코드의 다른 계층을 분할해서 얻는 장점보다 비용이 더 큰 시점이 올 수 있으므로 상식에 맞게 적용하는게 좋다.

### 예제 2.9

ParagraphFinder 클래스를 시작 오프셋 파인더, 종료 오프셋 파인더로 나눈다.

이 파인더들은 공통인터페이스 OffsetDetector를 implement한다.

이렇게 함으로써 좀 더 많은 계층을 갖는 코드가 보여진다.


> ParagraphFinder → \
OffsetDetector(Interface) → \
ParagraphStartOffsetDetector  || ParagraphEndOffsetDetector
>
ParagraphStartOffsetDetector  || ParagraphEndOffsetDetector 이 코드들은 다른곳에서 사용될 가능성이 없기에 코드의 계층이 너무 얇아졌다. **불필요하게 계층을 너무 잘게 쪼갰다.**


### 코드 계층 규모 결정

코드 계층 규모를 올바르게 결정하는 것은 중요하다.

계층이 너무 크면 쪼개져야 할 여러 추상화가 모듈화되지 않았고, 재사용 못하며, 가독성이 낮다.

계층이 너무 얇으면 불필요한 복잡성일 초래한다.

**일반적으로 너무 많은 일을 하는 계층은 너무 적은 일을 하는 계층보다 문제가 될 수 있다.**

계층이 너무 두꺼운지 판별할 기준은 없다.

자신이 만든 계층이 코드 가독성을 높이고, 재사용 가능하고, 일반화할수 있고, 모듈화되는지 스스로 판단하고 생각해보라.

